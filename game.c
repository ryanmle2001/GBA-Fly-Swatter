#include "game.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/garbage.h"
#include "images/apple.h"
#include "images/farm.h"
#include "images/fly.h"
#include "images/fly_swatter.h"
#include "images/grass.h"
#include "images/garbage.h"


/* TODO: */
// Add any additional states you need for your app.
typedef enum {
  START,
  PLAY,
  WIN,
  LOSE,
} GBAState;


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial game state
  GBAState state = START;

  // boolean that enables the welcome and end screen to be drawn once
  int stateTrigger = 1;

  // player lives and points
  int score = 0;
  int lives = LIVES;
  int added = 0;

  // defining fruit
  fruit.row = HEIGHT / 2 - APPLE_HEIGHT / 2;
  fruit.col = WIDTH / 2 - APPLE_WIDTH / 2;

  // boolean flags
  int lifeLost = 0;
  int flySwatted = 0;

  // speeds of the flies
  int speeds[] = {-1, 1};
  int nspeeds = sizeof(speeds) / sizeof(speeds[0]);

  // defining flies in the swarm of flies
  for (int i = 0; i < MAX_FLIES; i++) {
    cs.flies[i].row = rand() % HEIGHT;
    cs.flies[i].col = rand() % WIDTH;
    cs.flies[i].rd = speeds[rand() % nspeeds];
    cs.flies[i].cd = speeds[rand() % nspeeds];
  }
  cs.nfly = MAX_FLIES;
  cs.size = FLY_HEIGHT;

  // defining fly swatter
  cs.player.row = (HEIGHT + cs.size) / 2;
  cs.player.col = (WIDTH + cs.size) / 2;
  cs.player.size = FLY_SWATTER_WIDTH;

  // displayed text
  // welcome screen text
  char welcome[] = "Fly Frenzy";
  char welcome2[] = "Click Start to Begin";

  // end screen text
  char end[] = "You LOSE!";
  char end2[] = "Click Start to Play Again";

  // points tracker
  char s[] = "Score: ";
  char sbuffer[10];

  // lives tracker
  char l[] = "Lives: ";
  char lbuffer[10];

  sprintf(sbuffer, "%s%d", s, score);
  sprintf(lbuffer, "%s%d", l, lives);

  while (1) {
    currentButtons = BUTTONS;  // Load the current state of the buttons
    ps = cs;
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    switch (state) {
      case START:
        if (stateTrigger) {
          waitForVBlank();

          // draws the home screen once, using the stateTrigger
          drawFullScreenImageDMA(farm);  
          drawCenteredString(HEIGHT / 4, WIDTH / 4, 100, 20, welcome, BLACK);
          drawCenteredString(HEIGHT / 4 + 10, WIDTH / 3, 70, 20, welcome2, BLACK);
          stateTrigger = 0;
        }

        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          waitForVBlank();
          fillScreenDMA(GREEN);
        }
        break;
      case PLAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = LOSE;
          stateTrigger = 0;
        }

        // player moves down 
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          if (cs.player.row >= 15 && cs.player.row + cs.player.size < HEIGHT - 1) {
            cs.player.row++;
          }
        }
        //player moves up 
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          if (cs.player.row > 15 && cs.player.row + cs.player.size < HEIGHT) {
            cs.player.row--;
          }
        }
        //player moves right
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          if (cs.player.col >= 15 && cs.player.col + cs.player.size < WIDTH - 1) {
            cs.player.col++;
          }
        }
        //player moves left 
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          if (cs.player.col > 15 && cs.player.col + cs.player.size < WIDTH) {
            cs.player.col--;
          }
        }

        // updating movement of flies
        for (int i = 0; i < cs.nfly; i++) {
          cs.flies[i].row = cs.flies[i].row + cs.flies[i].rd;
          cs.flies[i].col += cs.flies[i].cd;
          if(cs.flies[i].row < 15) {
            cs.flies[i].row = 15;
            cs.flies[i].rd = -cs.flies[i].rd;
          }
          if(cs.flies[i].row > 159-cs.size+1) {
            cs.flies[i].row = 159-cs.size+1;
            cs.flies[i].rd = -cs.flies[i].rd;
          }
          if(cs.flies[i].col < 15) {
            cs.flies[i].col = 15;
            cs.flies[i].cd = -cs.flies[i].cd;
          }
          if(cs.flies[i].col > 239-cs.size+1) {
            cs.flies[i].col = 239-cs.size+1;
            cs.flies[i].cd = -cs.flies[i].cd;
          }
        }

        // win condition: if the fly swatter hits a fly
        for (int i = 0; i < cs.nfly; i++) {
          // contacts from the left side 
          for (int j = 0; j < cs.size; j++) {
            if (cs.flies[i].row + j >= cs.player.row && cs.flies[i].row + j < cs.player.row + cs.player.size && cs.flies[i].col + j >= cs.player.col && cs.flies[i].col + j < cs.player.col + cs.player.size) {
              flySwatted = 1;
            }
            // contacts from the top side
            if (cs.flies[i].row + j >= cs.player.row && cs.flies[i].col + j >= cs.player.col && cs.flies[i].col + j < cs.player.col + cs.player.size && cs.flies[i].row + j < cs.player.row + cs.player.size) {
              flySwatted = 1;
            }
            // contacts from the right side
            if (cs.flies[i].row + j >= cs.player.row && cs.flies[i].row + j < cs.player.row + cs.player.size && cs.flies[i].col + j <= cs.player.col + cs.player.size - 1 && cs.flies[i].col + j >= cs.player.col) {
              flySwatted = 1;
            }
            // contacts from the botton side
            if (cs.flies[i].row + j <= cs.player.row + cs.player.size - 1 && cs.flies[i].col + j >= cs.player.col && cs.flies[i].col + j < cs.player.col + cs.player.size && cs.flies[i].row + j >= cs.player.row) {
              flySwatted = 1;
            }
          }

          // win condition
          if (flySwatted) {
            state = WIN;
            cs.flies[i].row = rand() % HEIGHT;
            cs.flies[i].col = rand() % WIDTH;
            cs.flies[i].rd = speeds[rand() % nspeeds];
            cs.flies[i].cd = speeds[rand() % nspeeds];
            flySwatted = 0;

            // updating score on win condition
            score++;
            added++;
            if (added % 5 == 0) {
              lives++;
              added = 0;
            }
          }
        }

        // loss condition: if the fly touches the fruit from any side
        for (int i = 0; i < cs.nfly; i++) {
          // contacts from the left side 
          for (int j = 0; j < cs.size; j++) {
            if (cs.flies[i].row + j >= fruit.row && cs.flies[i].row + j < fruit.row + APPLE_HEIGHT && cs.flies[i].col + j >= fruit.col && cs.flies[i].col + j < fruit.col + APPLE_WIDTH) {
              lifeLost = 1;
            }
            // contacts from the top side
            if (cs.flies[i].row + j >= fruit.row && cs.flies[i].col + j >= fruit.col && cs.flies[i].col + j < fruit.col + APPLE_WIDTH && cs.flies[i].row + j < fruit.row + APPLE_HEIGHT) {
              lifeLost = 1;
            }
            // contacts from the right side
            if (cs.flies[i].row + j >= fruit.row && cs.flies[i].row + j < fruit.row + APPLE_HEIGHT && cs.flies[i].col + j <= fruit.col + APPLE_WIDTH - 1 && cs.flies[i].col + j >= fruit.col) {
              lifeLost = 1;
            }
            // contacts from the botton side
            if (cs.flies[i].row + j <= fruit.row + APPLE_HEIGHT - 1 && cs.flies[i].col + j >= fruit.col && cs.flies[i].col + j < fruit.col + APPLE_WIDTH && cs.flies[i].row + j >= fruit.row) {
              lifeLost = 1;
            }
          }
          if (lifeLost) {
            cs.flies[i].row = rand() % HEIGHT;
            cs.flies[i].col = rand() % WIDTH;
            cs.flies[i].rd = speeds[rand() % nspeeds];
            cs.flies[i].cd = speeds[rand() % nspeeds];
            lives--;
            lifeLost = 0;
          }
          if (lives == 0) {
            state = LOSE;
            stateTrigger = 0;
          }
        }
        break;  
      case WIN:
        state = PLAY;
        break;
      case LOSE:
        if (!stateTrigger) {
          waitForVBlank();

          //drawing end screen
          drawFullScreenImageDMA(grass);  
          drawCenteredString(HEIGHT / 34, WIDTH / 4, 100, 20, sbuffer, YELLOW);
          drawCenteredString(HEIGHT / 3, WIDTH / 4, 100, 20, end, YELLOW);
          drawCenteredString(HEIGHT / 3 + 10, WIDTH / 3, 70, 20, end2, YELLOW);

          //reset stateTrigger 
          stateTrigger = 1;
        }
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          lives = LIVES;
          score = 0;
          added = 0;
          state = PLAY;
          waitForVBlank();
          fillScreenDMA(GREEN);
        }
        break;

      }
    if (state == PLAY || state == WIN) {
      waitForVBlank();

      // drawing scoreline
      strcpy(sbuffer, "");
      strcpy(lbuffer, "");
      sprintf(sbuffer, "%s%d", s, score);
      sprintf(lbuffer, "%s%d", l, lives);
      drawRectDMA(0,0, WIDTH, 15, WHITE);
      drawString(3, 2, sbuffer, BLACK);
      drawString(2, WIDTH / 2, lbuffer, BLACK);

      // drawing fly swatter image
      drawRectDMA(ps.player.row, ps.player.col, ps.player.size, ps.player.size, GREEN);
      drawImageDMA(cs.player.row, cs.player.col, cs.player.size, cs.player.size, fly_swatter);

      // blacking out old fly position
      for (int i = 0; i < cs.nfly; i++) {
        drawRectDMA(ps.flies[i].row, ps.flies[i].col, 
          FLY_WIDTH, FLY_HEIGHT, GREEN);
      }

      // drawing new fly position
      for (int i = 0; i < cs.nfly; i++) {
        drawImageDMA(cs.flies[i].row, cs.flies[i].col, 
          FLY_WIDTH, FLY_HEIGHT, fly);
      }

      // drawing fruit image
      drawImageDMA(fruit.row, fruit.col, APPLE_WIDTH, APPLE_HEIGHT, apple);


    }
    previousButtons = currentButtons;  // Store the current state of the buttons
  }
  return 0;
}
